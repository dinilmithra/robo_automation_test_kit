<!-- Results Table Component -->
<div class="execution-summary">
    {% set has_passed = report_rows|selectattr('test_status', 'equalto', 'PASSED')|list|length > 0 %}
    {% set has_failed = report_rows|selectattr('test_status', 'equalto', 'FAILED')|list|length > 0 %}
    {% set has_skipped = report_rows|selectattr('test_status', 'equalto', 'SKIPPED')|list|length > 0 %}
    <span class="execution-label">
        {% if has_passed %}
        <input type="checkbox" class="status-filter" value="PASSED" checked>
        <label for="status-passed" class="passed">PASSED</label>
        {% endif %}
        {% if has_failed %}
        <input type="checkbox" class="status-filter" value="FAILED" checked>
        <label for="status-failed" class="failed">FAILED</label>
        {% endif %}
        {% if has_skipped %}
        <input type="checkbox" class="status-filter" value="SKIPPED" checked>
        <label for="status-skipped" class="skipped">SKIPPED</label>
        {% endif %}
    </span>
    <input type="text" class="filter-input" id="resultsTableFilter" placeholder="Filter results...">
    <span class="execution-details">
        Executed <span class="execution-count">{{ summary.total }}</span> test cases in <span class="execution-count">{{
            summary.duration }}</span> (HH:MM:SS)
    </span>
</div>

<table class="results-table" id="resultsTable">
    <thead>
        <tr>
            <th class="row_number" data-column-type="row_number">#</th>
            <th class="sortable test_status" data-column-type="test_status">Status</th>
            <th class="sortable test_case_name" data-column-type="test_case_name">Test Case Name</th>
            <th class="sortable phase" data-column-type="phase">Phase</th>
            <th class="sortable request_category" data-column-type="request_category">Request Category</th>
            <th class="sortable request_sub_category" data-column-type="request_sub_category">Request Sub-Category</th>
            <th class="sortable center" data-column-type="center">Center</th>
            <th class="sortable duration" data-column-type="duration">Duration</th>
        </tr>
    </thead>
    <tbody>
        {% for row in report_rows %}
        <tr data-test-name="{{ row.test_case_name|e }}" data-outcome="{{ row.test_status|e }}"
            data-error="{{ row.error_log|e }}">
            <td>{{ loop.index }}</td>
            <td class="status-{{ row.test_status|lower }}">
                {{ row.test_status }}
            </td>
            <td>{{ row.test_case_name or '' }}</td>
            <td>{{ row['Phase'] or '' }}</td>
            <td>{{ row['Request Category'] or '' }}</td>
            <td>{{ row['Request Sub-Category'] or '' }}</td>
            <td>{{ row['Center'] or '' }}</td>
            <td data-value="{{ row['duration']|default(0, true)|int }}">{{ format_duration(row['duration'])|default('',
                true) }}</td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Error Modal Markup -->
<div id="errorModal" class="error-modal">
    <div id="errorModalContent" class="error-modal-content">
        <div class="error-modal-header">
            <span id="errorModalTitle" class="error-modal-title"></span>
            <div class="error-modal-controls">
                <!-- Material Icons Expand/Minimize Buttons -->
                <span id="expandIcon" class="modal-header-icon material-icons" title="Maximize"
                    onclick="toggleFullscreen()">open_in_full</span>
                <span id="minimizeIcon" class="modal-header-icon material-icons" title="Minimize" style="display:none;"
                    onclick="toggleFullscreen()">minimize</span>
                <button class="modal-header-icon error-modal-btn" title="Close"
                    onclick="closeErrorModal()">&times;</button>
            </div>
        </div>
        <div id="errorModalBody">
            <div id="errorMessage" class="error-message"></div>
        </div>
    </div>
</div>

<script>
    // Results Table: Filtering and Error Modal Logic

    // Reindex the row numbers based on visible rows
    function reindexVisibleRows(table) {
        if (!table) {
            return;
        }

        const tbody = table.querySelector('tbody');
        if (!tbody) {
            return;
        }

        const rows = tbody.querySelectorAll('tr');
        let visibleIndex = 1;

        rows.forEach((row, i) => {
            // Check if row is visible (display is not 'none')
            const computedStyle = window.getComputedStyle(row);
            const isVisible = computedStyle.display !== 'none';

            if (isVisible && row.cells && row.cells[0]) {
                const oldValue = row.cells[0].textContent;
                row.cells[0].textContent = visibleIndex;
                visibleIndex++;
            }
        });
    }

    // Filter table based on status checkboxes and search input
    function setupTableFilters() {
        const statusFilters = document.querySelectorAll('.status-filter');
        const searchInput = document.getElementById('resultsTableFilter');
        const table = document.getElementById('resultsTable');

        if (!table || statusFilters.length === 0) return;

        function filterTable() {
            const selectedStatuses = Array.from(statusFilters)
                .filter(f => f.checked)
                .map(f => f.value.toUpperCase());

            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            const rows = table.querySelectorAll('tbody tr');

            rows.forEach((row, index) => {
                const statusCell = row.cells[1];
                if (!statusCell) return;

                const status = statusCell.textContent.trim().toUpperCase();

                // Only show rows that match CHECKED statuses (if any are checked)
                // If no statuses are checked, hide all rows
                const matchesStatus = selectedStatuses.length > 0 && selectedStatuses.includes(status);

                // Check if row text matches search term
                const rowText = Array.from(row.cells).map(c => c.textContent.toLowerCase()).join(' ');
                const matchesSearch = searchTerm === '' || rowText.includes(searchTerm);

                const shouldShow = matchesStatus && matchesSearch;
                row.style.display = shouldShow ? '' : 'none';
            });

            // Reindex visible rows after filtering
            reindexVisibleRows(table);
        }

        // Attach change listeners to checkboxes
        statusFilters.forEach(filter => {
            filter.addEventListener('change', filterTable);
        });

        // Attach input listener to search box
        if (searchInput) {
            searchInput.addEventListener('input', filterTable);
        }

        // Apply filter on initial load
        filterTable();
    }

    // Set up filters when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupTableFilters);
    } else {
        setupTableFilters();
    }

    // Ensure reindexing happens after page fully loads and filters are applied
    window.addEventListener('load', function () {
        const table = document.getElementById('resultsTable');
        if (table) {
            // Delay to ensure filters have been applied
            setTimeout(function () {
                reindexVisibleRows(table);
            }, 200);
        }
    });

    // Error modal logic
    window.showErrorDetails = function (row) {
        document.querySelectorAll('.results-table tr.selected').forEach(tr => tr.classList.remove('selected'));
        row.classList.add('selected');
        const testName = row.getAttribute('data-test-name') || 'Unknown Test';
        const outcome = row.getAttribute('data-outcome') || 'Unknown';
        const error = row.getAttribute('data-error') || 'No error details available';
        
        document.getElementById('errorModalTitle').textContent = `${testName} - ${outcome.toUpperCase()}`;
        
        // Format error message with highlighting (matching report_template.html format)
        const errorElement = document.getElementById('errorMessage');
        if (error && error.trim() !== '' && error !== 'No error details available') {
            // Highlight error message lines (lines starting with E   followed by exception type)
            // But do NOT highlight the Stacktrace marker or stacktrace content itself
            let formattedMessage = error;
            let stackPattern = /(E\s{1,3}Stacktrace:)/g;
            let parts = [];
            let lastIndex = 0;
            let match;
            
            while ((match = stackPattern.exec(formattedMessage)) !== null) {
                // Highlight error lines before the stacktrace marker
                let part = formattedMessage.substring(lastIndex, match.index);
                part = part.replace(
                    /^(E\s{1,3})(.*?)(: |$)/gm,
                    function(m, p1, p2, p3) {
                        return p1 + '<span style="color: red; font-weight: bold;">' + p2 + '</span>' + p3;
                    }
                );
                parts.push(part);
                // Add the stacktrace marker itself (unhighlighted)
                parts.push(match[1]);
                // Add all following lines up to the next error block or end (unhighlighted)
                let stackStart = match.index + match[1].length;
                let nextErrorBlock = formattedMessage.indexOf('\nE ', stackStart);
                if (nextErrorBlock === -1) nextErrorBlock = formattedMessage.length;
                let stacktraceContent = formattedMessage.substring(stackStart, nextErrorBlock);
                parts.push(stacktraceContent);
                lastIndex = nextErrorBlock;
                stackPattern.lastIndex = nextErrorBlock;
            }
            
            // Process the remainder after the last stacktrace
            let remainder = formattedMessage.substring(lastIndex);
            remainder = remainder.replace(
                /^(E\s{1,3})(.*?)(Message: |$)/gm,
                function(m, p1, p2, p3) {
                    return p1 + '<span style="color: red; font-weight: bold;">' + p2 + '</span>' + p3;
                }
            );
            parts.push(remainder);
            errorElement.innerHTML = parts.join('');
        } else {
            errorElement.innerHTML = '<em style="color: #666;">No detailed error information available for this test case.</em>';
        }
        
        document.getElementById('errorModal').style.display = 'block';
        document.getElementById('expandIcon').style.display = '';
        document.getElementById('minimizeIcon').style.display = 'none';
    };

    // closeErrorModal is defined in report.js with full cleanup functionality
    // DO NOT redefine it here as it will override the complete implementation

    // toggleFullscreen is defined in report.js with full resize functionality
    // DO NOT redefine it here as it will override the complete implementation

    window.onclick = function (event) {
        const modal = document.getElementById('errorModal');
        const modalContent = document.getElementById('errorModalContent');
        
        // Don't close if clicking on the modal content itself or if resizing
        if (event.target === modal && !modalContent.classList.contains('resizing')) {
            window.closeErrorModal();
        }
    };

    document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
            const modal = document.getElementById('errorModal');
            if (modal && modal.style.display === 'block') {
                window.closeErrorModal();
            }
        }
    });

    // Attach click event to table rows for error popup
    var table = document.getElementById('resultsTable');
    if (table) {
        table.querySelectorAll('tbody tr').forEach(function (row) {
            row.addEventListener('click', function () {
                showErrorDetails(row);
            });
        });
    }

    // Resize handling is managed by report.js - no need for duplicate listeners here
</script>