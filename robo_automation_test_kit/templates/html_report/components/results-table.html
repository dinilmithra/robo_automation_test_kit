<!-- Results Table Component -->
<div class="execution-summary">
    {% set has_passed = report_rows|selectattr('test_status', 'equalto', 'PASSED')|list|length > 0 %}
    {% set has_failed = report_rows|selectattr('test_status', 'equalto', 'FAILED')|list|length > 0 %}
    {% set has_skipped = report_rows|selectattr('test_status', 'equalto', 'SKIPPED')|list|length > 0 %}
    <span class="execution-label">
        {% if has_passed %}
        <input type="checkbox" class="status-filter" value="PASSED" checked>
        <label for="status-passed" class="passed">PASSED</label>
        {% endif %}
        {% if has_failed %}
        <input type="checkbox" class="status-filter" value="FAILED" checked>
        <label for="status-failed" class="failed">FAILED</label>
        {% endif %}
        {% if has_skipped %}
        <input type="checkbox" class="status-filter" value="SKIPPED" checked>
        <label for="status-skipped" class="skipped">SKIPPED</label>
        {% endif %}
    </span>
    <input type="text" class="filter-input" id="resultsTableFilter" placeholder="Filter results...">
    <span class="execution-details">
        Executed <span class="execution-count">{{ summary.total }}</span> test cases in <span class="execution-count">{{
            summary.duration }}</span> (HH:MM:SS)
    </span>
</div>

<table class="results-table" id="resultsTable">
    <thead>
        <tr>
            <th class="row_number" data-column-type="row_number">#</th>
            <th class="sortable test_status" data-column-type="test_status">Status</th>
            <th class="sortable test_case_name" data-column-type="test_case_name">Test Case Name</th>
            <th class="sortable phase" data-column-type="phase">Phase</th>
            <th class="sortable request_category" data-column-type="request_category">Request Category</th>
            <th class="sortable request_sub_category" data-column-type="request_sub_category">Request Sub-Category</th>
            <th class="sortable center" data-column-type="center">Center</th>
            <th class="sortable duration" data-column-type="duration">Duration</th>
        </tr>
    </thead>
    <tbody>
        {% for row in report_rows %}
        <tr data-test-name="{{ row.test_case_name|e }}" data-outcome="{{ row.test_status|e }}"
            data-error="{{ row.error_log|e }}">
            <td>{{ loop.index }}</td>
            <td class="status-{{ row.test_status|lower }}">
                {{ row.test_status }}
            </td>
            <td>{{ row.test_case_name or '' }}</td>
            <td>{{ row['Phase'] or '' }}</td>
            <td>{{ row['Request Category'] or '' }}</td>
            <td>{{ row['Request Sub-Category'] or '' }}</td>
            <td>{{ row['Center'] or '' }}</td>
            <td data-value="{{ row['duration']|default(0, true)|int }}">{{ format_duration(row['duration'])|default('',
                true) }}</td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Error Modal Markup -->
<div id="errorModal" class="error-modal">
    <div id="errorModalContent" class="error-modal-content">
        <div class="error-modal-header">
            <span id="errorModalTitle" class="error-modal-title"></span>
            <div class="error-modal-controls">
                <!-- Material Icons Expand/Minimize Buttons -->
                <span id="expandIcon" class="modal-header-icon material-icons" title="Maximize"
                    onclick="toggleFullscreen()">open_in_full</span>
                <span id="minimizeIcon" class="modal-header-icon material-icons" title="Minimize" style="display:none;"
                    onclick="toggleFullscreen()">minimize</span>
                <button class="modal-header-icon error-modal-btn" title="Close"
                    onclick="closeErrorModal()">&times;</button>
            </div>
        </div>
        <div id="errorModalBody">
            <div id="errorMessage" class="error-message"></div>
        </div>
    </div>
</div>

<script>
    // Results Table: Filtering and Error Modal Logic

    // Reindex the row numbers based on visible rows
    function reindexVisibleRows(table) {
        if (!table) {
            return;
        }

        const tbody = table.querySelector('tbody');
        if (!tbody) {
            return;
        }

        const rows = tbody.querySelectorAll('tr');
        let visibleIndex = 1;

        rows.forEach((row, i) => {
            // Check if row is visible (display is not 'none')
            const computedStyle = window.getComputedStyle(row);
            const isVisible = computedStyle.display !== 'none';

            if (isVisible && row.cells && row.cells[0]) {
                const oldValue = row.cells[0].textContent;
                row.cells[0].textContent = visibleIndex;
                visibleIndex++;
            }
        });
    }

    // Filter table based on status checkboxes and search input
    function setupTableFilters() {
        const statusFilters = document.querySelectorAll('.status-filter');
        const searchInput = document.getElementById('resultsTableFilter');
        const table = document.getElementById('resultsTable');

        if (!table || statusFilters.length === 0) return;

        function filterTable() {
            const selectedStatuses = Array.from(statusFilters)
                .filter(f => f.checked)
                .map(f => f.value.toUpperCase());

            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            const rows = table.querySelectorAll('tbody tr');

            rows.forEach((row, index) => {
                const statusCell = row.cells[1];
                if (!statusCell) return;

                const status = statusCell.textContent.trim().toUpperCase();

                // Only show rows that match CHECKED statuses (if any are checked)
                // If no statuses are checked, hide all rows
                const matchesStatus = selectedStatuses.length > 0 && selectedStatuses.includes(status);

                // Check if row text matches search term
                const rowText = Array.from(row.cells).map(c => c.textContent.toLowerCase()).join(' ');
                const matchesSearch = searchTerm === '' || rowText.includes(searchTerm);

                const shouldShow = matchesStatus && matchesSearch;
                row.style.display = shouldShow ? '' : 'none';
            });

            // Reindex visible rows after filtering
            reindexVisibleRows(table);
        }

        // Attach change listeners to checkboxes
        statusFilters.forEach(filter => {
            filter.addEventListener('change', filterTable);
        });

        // Attach input listener to search box
        if (searchInput) {
            searchInput.addEventListener('input', filterTable);
        }

        // Apply filter on initial load
        filterTable();
    }

    // Set up filters when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupTableFilters);
    } else {
        setupTableFilters();
    }

    // Ensure reindexing happens after page fully loads and filters are applied
    window.addEventListener('load', function () {
        const table = document.getElementById('resultsTable');
        if (table) {
            // Delay to ensure filters have been applied
            setTimeout(function () {
                reindexVisibleRows(table);
            }, 200);
        }
    });

    // Error modal logic
    window.showErrorDetails = function (row) {
        document.querySelectorAll('.results-table tr.selected').forEach(tr => tr.classList.remove('selected'));
        row.classList.add('selected');
        const testName = row.getAttribute('data-test-name') || 'Unknown Test';
        const outcome = row.getAttribute('data-outcome') || 'Unknown';
        const error = row.getAttribute('data-error') || 'No error details available';
        document.getElementById('errorModalTitle').textContent = `${testName} - ${outcome.toUpperCase()}`;
        document.getElementById('errorMessage').textContent = error;
        document.getElementById('errorModal').style.display = 'block';
        document.getElementById('expandIcon').style.display = '';
        document.getElementById('minimizeIcon').style.display = 'none';
    };

    window.closeErrorModal = function () {
        document.getElementById('errorModal').style.display = 'none';
        document.getElementById('errorModalContent').classList.remove('fullscreen');
        document.querySelectorAll('.results-table tr.selected').forEach(tr => tr.classList.remove('selected'));
    };

    window.toggleFullscreen = function () {
        const modalContent = document.getElementById('errorModalContent');
        const expandIcon = document.getElementById('expandIcon');
        const minimizeIcon = document.getElementById('minimizeIcon');
        const isFullscreen = modalContent.classList.toggle('fullscreen');
        if (isFullscreen) {
            expandIcon.style.display = 'none';
            minimizeIcon.style.display = '';
        } else {
            expandIcon.style.display = '';
            minimizeIcon.style.display = 'none';
        }
    };

    window.onclick = function (event) {
        const modal = document.getElementById('errorModal');
        if (event.target === modal) {
            window.closeErrorModal();
        }
    };

    document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
            const modal = document.getElementById('errorModal');
            if (modal && modal.style.display === 'block') {
                window.closeErrorModal();
            }
        }
    });

    // Attach click event to table rows for error popup
    var table = document.getElementById('resultsTable');
    if (table) {
        table.querySelectorAll('tbody tr').forEach(function (row) {
            row.addEventListener('click', function () {
                showErrorDetails(row);
            });
        });
    }
</script>